/*
 * SPDX-License-Identifier: Apache-2.0
 * SPDX-FileCopyrightText: Â© 2024 Dmitry Kireev
 */

package ssh

import (
	"fmt"
	"github.com/DimmKirr/atun/internal/config"
	"github.com/DimmKirr/atun/internal/logger"
	"github.com/shirou/gopsutil/v4/process"
	ssh2 "golang.org/x/crypto/ssh"
	"log"
	"net"
	"os"
	"os/exec"
	"path"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

// TODO: Refactor GetSSHCommandArgs into separate functions
type Endpoint struct {
	LocalHost  string
	LocalPort  int
	RemoteHost string
	RemotePort int
	Protocol   string
	Status     bool
}

// GetPublicKey gets the public key from the private key
func GetPublicKey(path string) (string, error) {
	if !filepath.IsAbs(path) {
		var err error
		path, err = filepath.Abs(path)
		if err != nil {
			return "", err
		}
	}

	if _, err := os.Stat(path); err != nil {
		return "", fmt.Errorf("%s does not exist", path)
	}

	f, err := os.ReadFile(path)
	if err != nil {
		return "", err
	}

	// Parse the private key
	privateKey, err := ssh2.ParsePrivateKey(f)
	if err != nil {
		return "", err
	}

	// Extract the public key from the private key
	publicKey := privateKey.PublicKey()

	// Marshal the public key to the OpenSSH format
	pubKeyBytes := ssh2.MarshalAuthorizedKey(publicKey)

	// Return the public key as a string
	return string(pubKeyBytes), nil
}

func GenerateSSHConfigFile(app *config.Atun) (string, error) {
	sshConfigContent := `# SSH over AWS Session Manager (generated by atun.io)
host i-* mi-*
ServerAliveInterval 180
ProxyCommand sh -c "aws ssm start-session --target %h --document-name AWS-StartSSHSession --parameters 'portNumber=%p'"
`

	for _, host := range app.Config.Hosts {
		logger.Debug("Endpoint", "name", host.Name, "proto", host.Proto, "remote", host.Remote, "local", host.Local)
		sshConfigContent += fmt.Sprintf("LocalForward %d %s:%d\n", host.Local, host.Name, host.Remote)
	}

	sshConfigFilePath := GetSSHConfigFilePath(app)
	sshConfigFile, err := os.Create(sshConfigFilePath)
	//sshConfigFile, err := os.CreateTemp(os.TempDir(), "atun-ssh.config")
	if err != nil {
		logger.Error("Error creating ssh tunnel config file", "error", err)
		return "", err
	}

	defer sshConfigFile.Close()

	// Write the content to the file
	_, err = sshConfigFile.WriteString(sshConfigContent)
	if err != nil {
		return "", err
	}

	return sshConfigFile.Name(), nil
}

func GetSSMPluginStatus(app *config.Atun) (bool, error) {
	// Check if `session-manager-plugin' is started and process contains Router instance ID
	cmd := exec.Command("ps", "aux")
	output, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("failed to check SSM plugin status: %w", err)
	}

	if !strings.Contains(string(output), app.Config.RouterHostID) {
		return false, nil
	}

	return true, nil
}

func GetSSHTunnelStatus(app *config.Atun) (bool, []Endpoint, error) {
	// TODO: Add port check too to make sure to see outrun tunnels
	var endpoints []Endpoint

	// Pre-populate Endpoints
	for _, v := range app.Config.Hosts {
		logger.Debug("Endpoint", "name", v.Name, "proto", v.Proto, "remote", v.Remote, "local", v.Local)

		endpoints = append(endpoints, Endpoint{
			LocalHost:  "127.0.0.1",
			LocalPort:  v.Local,
			RemoteHost: v.Name,
			RemotePort: v.Remote,
			Protocol:   v.Proto,
			Status:     false,
		})
	}
	// Get all active tunnels (all environments)
	activeSSHTunnels, err := GetActiveSSHTunnels()
	if err != nil {
		logger.Debug("No running tunnels found")
		return false, endpoints, nil
	}

	if len(activeSSHTunnels) < 1 {
		logger.Debug("No running ssh tunnel processes found")
		return false, endpoints, nil
	}

	var activeOwnedTunnels []config.Config
	// Check if any of the tunnels have the same RouterHostID
	for _, v := range activeSSHTunnels {
		if v.RouterHostID == app.Config.RouterHostID {
			logger.Debug("Found running tunnel with the current RouterHostID", "routerHostID", app.Config.RouterHostID)
			activeOwnedTunnels = append(activeOwnedTunnels, v)
		}
	}

	if len(activeOwnedTunnels) < 1 {
		logger.Debug("No running tunnels found with the current RouterHostID", "routerHostID", app.Config.RouterHostID)
		return false, nil, nil
	}

	logger.Debug("Found running tunnels", "tunnels", activeOwnedTunnels)

	routerSockFilePath := GetRouterSockFilePath(app)

	// If a router socket file exists, check the tunnel status by sending an ssh command and then checking the port
	if _, err := os.Stat(routerSockFilePath); !os.IsNotExist(err) {
		logger.Debug("An existing tunnel socket found", "path", routerSockFilePath)

		// Pass "check" command to see if the socket has a valid SSH connection
		args := []string{"ssh", "-S", routerSockFilePath, "-O", "check", ""}

		// Run the SSH command in a blocking way
		cmd := exec.Command("ssh", args...)
		cmd.Dir = app.Config.AppDir

		if app.Config.LogLevel == "debug" {
			cmd.Args = append(cmd.Args, "-vvv")
		}
		logger.Debug("Running SSH command", "command", cmd.String())
		sshMasterProcessOutput, err := cmd.CombinedOutput()
		if err != nil {
			logger.Debug("Error checking status of the tunnel", "error", err)
		}

		if strings.Contains(string(sshMasterProcessOutput), "running") {
			// Fill in connections with the tunnel connections from Hosts
			for k, v := range endpoints {
				var endpointActive bool

				//logger.Debug("Endpoint", "name", v.Name, "proto", v.Proto, "remote", v.Remote, "local", v.Local)

				// TODO: Get args too to get the full connection to match the env / routerID
				// check if the v.Local port is occupied
				portUsed, processName, err := CheckPort(v.LocalPort)
				if err != nil {
					log.Fatalf("Error checking port status: %v", err)
				}

				if portUsed && processName == "ssh" {
					endpointActive = true
					logger.Debug("Port is occupied by ssh", "port", v.LocalPort)
				} else {
					endpointActive = false
					logger.Debug("Port is not used by ssh", "port", v.LocalPort)
				}

				logger.Debug("Port status", "port", v.LocalPort, "status", portUsed)

				endpoints[k].Status = endpointActive
			}

			return true, endpoints, nil
		} else {
			logger.Debug("Master Tunnel is not running", "output", sshMasterProcessOutput)
		}

		return false, nil, nil

	}

	logger.Debug("Tunnel socket not found. Tunnel is not running", "path", routerSockFilePath)
	return false, endpoints, nil
}

func StartSSHTunnel(app *config.Atun) error {
	routerSockFilePath := GetRouterSockFilePath(app)

	args := []string{}

	// Check if the router socket file exists

	tunnelActive, _, err := GetSSHTunnelStatus(app)
	if err != nil {
		return fmt.Errorf("failed to get tunnel status: %w", err)
	}

	if !tunnelActive {
		logger.Debug("Tunnel socket not found. Creating a new one", "path", routerSockFilePath)
		args = []string{"-M", "-t", "-S", routerSockFilePath, "-fN"}

		// Disable strict host key checking
		if !app.Config.SSHStrictHostKeyChecking {
			args = append(args, "-o", "StrictHostKeyChecking=no")
		}

		// TODO: Add ability to support other instance types, not just AWS Linux
		args = append(args, fmt.Sprintf("%s@%s", app.Config.RouterHostUser, app.Config.RouterHostID))
		args = append(args, "-F", app.Config.SSHConfigFile)

		if _, err := os.Stat(app.Config.SSHKeyPath); !os.IsNotExist(err) {
			args = append(args, "-i", app.Config.SSHKeyPath)
		}
	}

	if app.Config.LogLevel == "debug" {
		args = append(args, "-vvv")
	}

	logger.Debug("SSH", "args", args)
	c := exec.Command("ssh", args...)
	logger.Debug("SSH command", "command", c.String())

	c.Dir = app.Config.AppDir
	os.Setenv("AWS_REGION", app.Config.AWSRegion)
	os.Setenv("AWS_PROFILE", app.Config.AWSProfile)

	// Detach the process (platform-dependent)
	// Platform-specific implementation is in sysproc_*.go files
	setupSysProcAttr(c)

	//// Stream stdout and stderr
	//if app.Config.LogLevel == "debug" {
	//	// Stream output to os.Stdout and os.Stderr in real-time
	//	stdoutPipe, err := c.StdoutPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stdout pipe: %w", err)
	//	}
	//	stderrPipe, err := c.StderrPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stderr pipe: %w", err)
	//	}
	//
	//	go io.Copy(os.Stdout, stdoutPipe)
	//	go io.Copy(os.Stderr, stderrPipe)
	//} else {
	// Only display logs without streaming
	//c.Stdout = os.Stdout
	//c.Stderr = os.Stderr
	//}
	//if app.Config.LogLevel == "debug" {
	//	stdout, err := c.StdoutPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stdout pipe: %w", err)
	//	}
	//
	//	stderr, err := c.StderrPipe()
	//	if err != nil {
	//		return fmt.Errorf("failed to get stderr pipe: %w", err)
	//	}
	//
	//	go io.Copy(os.Stdout, stdout)
	//	go io.Copy(os.Stderr, stderr)
	//}
	// Run the command
	if err := c.Run(); err != nil {
		logger.Debug("SSH command error", "error", err)
		return fmt.Errorf("failed to run SSH process: %w", err)

		// Print stdot and stderr from the command

	}

	logger.Debug("SSH process started in the background", "pid", c.Process.Pid)

	// Disown the process if the parent process is terminating
	// This ensures the child process doesn't get terminated when the parent exits
	go func() {
		_ = c.Process.Release() // Detach the process fully
	}()

	return nil
}

// StopSSHTunnel stops the SSH tunnel and returns false if the tunnel is not running
func StopSSHTunnel(app *config.Atun) (bool, error) {
	routerSockFilePath := GetRouterSockFilePath(app)
	tunnelConfigFilePath := GetSSHConfigFilePath(app)

	// If a router socket file exists, check the tunnel status
	if _, err := os.Stat(routerSockFilePath); !os.IsNotExist(err) {
		logger.Debug("A tunnel socket from has been found", "path", routerSockFilePath)

		args := []string{"ssh", "-S", routerSockFilePath, "-O", "exit", ""}

		// Run the SSH command in a blocking way
		cmd := exec.Command("ssh", args...)
		logger.Debug("Running SSH command", "command", cmd.String())
		cmd.Dir = app.Config.AppDir

		if app.Config.LogLevel == "debug" {
			cmd.Args = append(cmd.Args, "-vvv")
		}

		if err := cmd.Run(); err != nil {
			return false, fmt.Errorf("failed to exit tunnel: %w", err)
		}
	}

	// Check if the router socket file exists and remove it if it does
	if _, err := os.Stat(tunnelConfigFilePath); err == nil {
		if err := os.Remove(tunnelConfigFilePath); err != nil {
			return false, fmt.Errorf("failed to remove router config file: %w", err)
		}
		logger.Debug("Removed router config file", "path", tunnelConfigFilePath)
	}

	tunnelActive, _, err := GetSSHTunnelStatus(app)
	if err != nil {
		return false, fmt.Errorf("failed to get tunnel status: %w", err)
	}

	if !tunnelActive {
		return tunnelActive, nil
	}

	logger.Error("Tunnel is still active. Likely a bug")
	return true, nil // return true, meaning tunnel status is "on"
}

func GetRouterSockFilePath(app *config.Atun) string {
	logger.Debug("Getting router socket file path", "tunnelDir", app.Config.TunnelDir, "env", app.Config.Env, "routerHostID", app.Config.RouterHostID)

	if app.Config.RouterHostID == "" {
		logger.Debug("Can't find Router Endpoint ID is not set. Assuming router id from existing socket file")

	}

	return path.Join(app.Config.TunnelDir, fmt.Sprintf("%s-tunnel.sock", app.Config.RouterHostID))
}

func GetSSHConfigFilePath(app *config.Atun) string {
	return path.Join(app.Config.TunnelDir, fmt.Sprintf("%s-ssh.config", app.Config.RouterHostID))
}

// GetActiveSSHTunnels gets all active SSH tunnels on this machine (all environments)
func GetActiveSSHTunnels() ([]config.Config, error) {
	var runningTunnels []config.Config
	///  ssh -M -t -S /Users/dmitry/.atun/adhoc-nutcorp-dev/i-059cde3acc2a0c8eb-tunnel.sock -fN -o StrictHostKeyChecking=no ec2-user@i-059cde3acc2a0c8eb -F /var/folders/g1/g6vwr5j95c76bc5tnq0ky2t40000gn/T/atun-ssh.config647105965 -i /Users/dmitry/.ssh/id_rsa

	// Define the regex routerInstancePattern

	// This regex is based on the cmd and args in ssh package
	sshProcessPattern := regexp.MustCompile(`.*-S\s+(?P<sshSocketFile>\S+).*\s+(?P<userName>[a-zA-Z_][a-zA-Z0-9._-]{0,31})@(?P<instanceId>i-[0-9a-f]{17}).*-F\s+(?P<sshConfigFile>\S+).*-i\s+(?P<sshKeyPath>\S+).*`)

	// Run the ps command to list all processes
	targetBinary := "ssh" // The binary name to match exactly

	// Get a list of all processes
	processes, err := process.Processes()
	if err != nil {
		log.Fatalf("Error retrieving processes: %v", err)
	}

	logger.Debug("Process matching binary", "targetBinary", targetBinary)
	for _, proc := range processes {
		// Get process name
		name, err := proc.Name()
		if err != nil {
			continue // Skip processes with inaccessible names
		}

		// Check for an exact match of the binary name
		if strings.EqualFold(strings.TrimSpace(name), targetBinary) {
			// Get process ID
			pid := proc.Pid

			// (Optional) Get full executable path
			exePath, err := proc.Exe()
			if err != nil {
				exePath = "N/A"
			}

			a, err := proc.CmdlineSlice()
			if err != nil {
				logger.Debug("Error getting process arguments, setting empty []string{}", "error", err)
				a = []string{}
			}

			args := strings.Join(a, " ")

			logger.Debug("Found process", "pid", pid, "name", name, "exePath", exePath)
			if sshProcessPattern.MatchString(args) {
				matches := sshProcessPattern.FindStringSubmatch(args)
				if matches == nil {
					continue
				}

				matchedSSHSocketFile := ""
				matchedUserName := ""
				matchedInstanceID := ""
				matchedSSHConfigFile := ""

				for i, name := range sshProcessPattern.SubexpNames() {
					switch name {
					case "sshSocketFile":
						matchedSSHSocketFile = matches[i]
					case "userName":
						matchedUserName = matches[i]
					case "instanceId":
						matchedInstanceID = matches[i]
					case "sshConfigFile":
						matchedSSHConfigFile = matches[i]
					}
				}

				runningTunnels = append(runningTunnels, config.Config{
					SSHConfigFile:  matchedSSHConfigFile,
					SSHSocketFile:  matchedSSHSocketFile,
					RouterHostID:   matchedInstanceID,
					RouterHostUser: matchedUserName,
				})
			}
		}
	}
	return runningTunnels, nil
}

// CheckPort checks if the port is occupied and returns true/false and also process name
func CheckPort(port int) (bool, string, error) {
	logger.Debug("Checking port", "port", port)
	addr, err := net.ResolveTCPAddr("tcp", fmt.Sprintf("127.0.0.1:%v", port))
	if err != nil {
		return false, "", fmt.Errorf("can't resolve address: %w", err)
	}

	conn, err := net.DialTCP("tcp", nil, addr)
	if err != nil {
		if opErr, ok := err.(*net.OpError); ok && opErr.Op == "dial" {
			// Port is not open
			return false, "", nil
		}
		return false, "", fmt.Errorf("error dialing TCP: %w", err)
	}
	defer conn.Close()

	// Check which process has created the socket
	pid, err := getProcessIDByPort(port)
	if err != nil {
		return true, "", fmt.Errorf("error getting process ID: %w", err)
	}

	processName, err := getProcessNameByPID(pid)
	if err != nil {
		return true, "", fmt.Errorf("error getting process name: %w", err)
	}

	return true, processName, nil
}

func getProcessIDByPort(port int) (int, error) {
	cmd := exec.Command("lsof", "-sTCP:LISTEN", "-i", fmt.Sprintf(":%d", port), "-t")
	output, err := cmd.Output()
	if err != nil {
		return 0, err
	}

	pidStr := strings.TrimSpace(string(output))
	if pidStr == "" {
		return 0, fmt.Errorf("no process found for port %d", port)
	}

	pid, err := strconv.Atoi(pidStr)
	if err != nil {
		return 0, err
	}

	return pid, nil
}

func getProcessNameByPID(pid int) (string, error) {
	proc, err := process.NewProcess(int32(pid))
	if err != nil {
		return "", err
	}

	name, err := proc.Name()
	if err != nil {
		return "", err
	}

	return name, nil
}

// getRouterHostIDFromSocket gets the router host ID from the router socket file
func GetRouterHostIDFromExistingSession(tunnelDir string) (string, error) {
	files, err := os.ReadDir(tunnelDir)
	if err != nil {
		return "", fmt.Errorf("failed to read tunnel directory: %w", err)
	}

	var tunnelFiles []string

	for _, file := range files {
		if strings.HasSuffix(file.Name(), "-tunnel.sock") {
			tunnelFiles = append(tunnelFiles, file.Name())
		}
	}

	logger.Debug("Tunnel socket files", "files", tunnelFiles)

	if len(tunnelFiles) > 1 {
		return "", fmt.Errorf("multiple router host IDs found in the tunnel directory %s. Likely due to abnormal termination before. Please clean up manually", tunnelDir)
	}

	if len(tunnelFiles) == 1 {
		routerHostID := strings.TrimSuffix(tunnelFiles[0], "-tunnel.sock")
		return routerHostID, nil
	}

	// TODO: attempt to get it from ssm processes

	return "", fmt.Errorf("no router host ID found in the tunnel directory")
}

// TerminateSSHProcessesWithRouterHostID terminates all SSH processes that have BastionHostID in their command line
func TerminateSSHProcessesWithRouterHostID(bastionHostID string) error {
	processes, err := process.Processes()
	if err != nil {
		return fmt.Errorf("error retrieving processes: %w", err)
	}

	for _, proc := range processes {
		cmdline, err := proc.Cmdline()
		if err != nil {
			continue // Skip processes with inaccessible command lines
		}

		if strings.Contains(cmdline, bastionHostID) {
			if err := proc.Terminate(); err != nil {
				logger.Error("Failed to terminate process", "pid", proc.Pid, "error", err)
			} else {
				logger.Debug("Terminated process", "pid", proc.Pid)
			}
		}
	}

	return nil
}

// TerminateSSMProcessesWithRouterHostID terminates all SSM processes that have RouterHostID in their command line
func TerminateSSMProcessesWithRouterHostID(routerHostID string) error {
	processes, err := process.Processes()
	if err != nil {
		return fmt.Errorf("error retrieving processes: %w", err)
	}

	for _, proc := range processes {
		cmdline, err := proc.Cmdline()
		if err != nil {
			continue // Skip processes with inaccessible command lines
		}

		if strings.Contains(cmdline, routerHostID) && strings.Contains(cmdline, "session-manager-plugin") {
			if err := proc.Terminate(); err != nil {
				logger.Error("Failed to terminate process", "pid", proc.Pid, "error", err)
			} else {
				logger.Info("Terminated process", "pid", proc.Pid)
			}
		}
	}

	return nil
}
